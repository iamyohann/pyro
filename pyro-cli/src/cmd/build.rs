use crate::util;
use anyhow::{Context, Result};
use pyro_core::ast::Stmt;
use pyro_core::transpiler::Transpiler;
use std::collections::HashSet;
use std::fs;
use std::path::PathBuf;
use std::process::Command;

use crate::BuildTarget;

pub fn r#impl(file: PathBuf, output: Option<PathBuf>, target: BuildTarget) -> Result<()> {
    println!("Building {:?}", file);

    // Generate externs relative to pyro.mod if present
    if let Ok(_manifest_path) = std::fs::canonicalize(file.parent().unwrap_or(std::path::Path::new("."))) { 
         let start_path = file.parent().unwrap_or(std::path::Path::new("."));
         let mut current = start_path.to_path_buf();
         loop {
             if current.join("pyro.mod").exists() {
                 let externs_dir = current.join(".externs");
                 // We don't fail build if extern generation fails, just warn or ignore?
                 // Best to try and log error execution but proceed if possible (though likely fail later)
                 if let Err(e) = crate::cmd::externs::generate_externs(&externs_dir) {
                     eprintln!("Warning: Failed to generate externs: {}", e);
                 }
                 break;
             }
             if !current.pop() { break; }
         }
    }

    let mut statements = Vec::new();
    let mut loaded = HashSet::new();
    
    util::process_file(file.clone(), &mut loaded, &mut statements)?;

    // Split statements into definitions (top-level) and executable statements (main)
    let mut defs = Vec::new();
    let mut main_stmts = Vec::new();

    for stmt in statements {
        match stmt {
            Stmt::FnDecl { .. } => defs.push(stmt),
            _ => main_stmts.push(stmt),
        }
    }

    let mut transpiler = Transpiler::new();
    
    let defs_rs = transpiler.transpile(defs);
    let main_rs = transpiler.transpile(main_stmts);

    let full_rs = format!(r#"#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_mut)]

// Generated by Pyro
fn main() {{
{}
}}

// Definitions
{}
"#, main_rs, defs_rs);

    // Setup build directory
    let build_dir = PathBuf::from("target/pyro_build");
    if build_dir.exists() {
        fs::remove_dir_all(&build_dir)?;
    }
    fs::create_dir_all(build_dir.join("src"))?;

    match target {
        BuildTarget::Rust => {
             // Copy binary
            let dest = if let Some(out) = output {
                out
            } else {
                let bin_name = file.file_stem().unwrap().to_str().unwrap();
                PathBuf::from(format!("{}.rs", bin_name))
            };
            
            fs::write(&dest, full_rs)?;
            println!("Transpilation successful! Rust file created: {:?}", dest);
        }
        BuildTarget::Binary => {
            // Write Main.rs
            fs::write(build_dir.join("src/main.rs"), full_rs)?;

            // Write Cargo.toml
            let cargo_toml = r#"[package]
name = "pyro_program"
version = "0.1.0"
edition = "2021"

[workspace]

[dependencies]
rand = "0.8"
async-channel = "2.3"
"#;
            fs::write(build_dir.join("Cargo.toml"), cargo_toml)?;

            fs::write(build_dir.join("Cargo.toml"), cargo_toml)?;

            println!("Compiling to native binary...");
            
            let abs_build_dir = build_dir.canonicalize()?;
            let status = Command::new("cargo")
                .arg("build")
                .arg("--release")
                .current_dir(&abs_build_dir)
                .status()
                .context("Failed to run cargo build")?;

            if !status.success() {
                anyhow::bail!("Compilation failed");
            }

            // Copy binary
            let dest = if let Some(out) = output {
                out
            } else {
                let bin_name = file.file_stem().unwrap().to_str().unwrap();
                PathBuf::from(bin_name)
            };
            
            fs::copy(build_dir.join("target/release/pyro_program"), &dest)?;

            println!("Build successful! Binary created: {:?}", dest);
        }
    }

    Ok(())
}
