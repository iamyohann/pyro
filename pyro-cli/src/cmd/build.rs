use crate::util;
use crate::manifest::Manifest;
use anyhow::{Context, Result};
use pyro_core::ast::Stmt;
use pyro_core::transpiler::Transpiler;
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

use crate::BuildTarget;

pub fn r#impl(file: PathBuf, output: Option<PathBuf>, target: BuildTarget) -> Result<()> {
    println!("Building {:?}", file);

    // Resolve Manifest
    let parent = file.parent().unwrap_or(Path::new("."));
    let search_path = if parent.as_os_str().is_empty() { Path::new(".") } else { parent };
    let manifest = Manifest::resolve_from(search_path).ok();

    // Generate externs relative to pyro.mod if present
    if let Ok(_manifest_path) = std::fs::canonicalize(search_path) { 
         let mut current = search_path.to_path_buf();
         loop {
             if current.join("pyro.mod").exists() {
                 let externs_dir = current.join(".externs");
                 // We don't fail build if extern generation fails, just warn or ignore?
                 // Best to try and log error execution but proceed if possible (though likely fail later)
                 if let Err(e) = crate::cmd::externs::generate_externs(&externs_dir) {
                     eprintln!("Warning: Failed to generate externs: {}", e);
                 }
                 break;
             }
             if !current.pop() { break; }
         }
    }

    let mut statements = Vec::new();
    let mut loaded = HashSet::new();
    
    util::process_file(file.clone(), &mut loaded, &mut statements)?;

    // Split statements into definitions (top-level) and executable statements (main)
    let mut defs = Vec::new();
    let mut main_stmts = Vec::new();

    for stmt in statements {
        match stmt {
            Stmt::FnDecl { .. } => defs.push(stmt),
            _ => main_stmts.push(stmt),
        }
    }

    let mut transpiler = Transpiler::new();
    
    let defs_rs = transpiler.transpile(defs);
    let main_rs = transpiler.transpile(main_stmts);

    let full_rs = format!(r#"#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_mut)]

// Generated by Pyro
fn main() {{
{}
}}

// Definitions
{}
"#, main_rs, defs_rs);

    // Setup build directory
    let build_dir = PathBuf::from("target/pyro_build");
    if build_dir.exists() {
        fs::remove_dir_all(&build_dir)?;
    }
    fs::create_dir_all(build_dir.join("src"))?;

    match target {
        BuildTarget::Rust => {
             // Copy binary
            let dest = if let Some(out) = output {
                out
            } else {
                let bin_name = file.file_stem().unwrap().to_str().unwrap();
                PathBuf::from(format!("{}.rs", bin_name))
            };
            
            fs::write(&dest, full_rs)?;
            println!("Transpilation successful! Rust file created: {:?}", dest);
        }
        BuildTarget::Binary => {
            // Write Main.rs
            fs::write(build_dir.join("src/main.rs"), full_rs)?;

            // Write Cargo.toml
            let mut dependencies = String::new();
            
            // Default dependencies
            let mut deps_map = std::collections::HashMap::new();
            deps_map.insert("rand".to_string(), "0.8".to_string());
            deps_map.insert("async-channel".to_string(), "2.3".to_string());
            
            if let Some(m) = &manifest {
                if let Some(rust_config) = &m.rust {
                    for (name, version) in &rust_config.dependencies {
                        deps_map.insert(name.clone(), version.clone());
                    }
                }
            }
            
            for (name, version) in deps_map {
                dependencies.push_str(&format!("{} = \"{}\"\n", name, version));
            }

            let cargo_toml = format!(r#"[package]
name = "pyro_program"
version = "0.1.0"
edition = "2021"

[workspace]

[dependencies]
{}
"#, dependencies);
            fs::write(build_dir.join("Cargo.toml"), cargo_toml)?;



            println!("Compiling to native binary...");
            
            let abs_build_dir = build_dir.canonicalize()?;
            let status = Command::new("cargo")
                .arg("build")
                .arg("--release")
                .current_dir(&abs_build_dir)
                .status()
                .context("Failed to run cargo build")?;

            if !status.success() {
                anyhow::bail!("Compilation failed");
            }

            // Copy binary
            let dest = if let Some(out) = output {
                out
            } else {
                let bin_name = file.file_stem().unwrap().to_str().unwrap();
                PathBuf::from(bin_name)
            };
            
            fs::copy(build_dir.join("target/release/pyro_program"), &dest)?;

            println!("Build successful! Binary created: {:?}", dest);
        }
    }

    Ok(())
}
